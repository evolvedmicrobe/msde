#'@name msde-package
#'@docType package
#'@aliases msde
#'@title Bayesian Inference for Multivariate Stochastic Differential Equations
#'@description MCMC sampling of the posterior distribution of the parameters of a multivariate SDE model given discretely observed data.  The user-defined models in msde are compiled in C++ which results in considerably faster posterior sampling than if the models were written in R.
#'@examples
#'
#'# create the sde.model object for Heston's stochastic volatility model
#'hest.model <- sde.make.model(list = hestList, cpp.out = TRUE)
#'
#'# simulate data
#'
#'# model parameters
#'alpha <- .1
#'gamma <- 5.07
#'mu <- .05
#'sigma <- .48
#'rho <- -.77
#'beta <- 2*gamma*mu - sigma^2/2
#'theta <- c(alpha = alpha, gamma = gamma, beta = beta, sigma = sigma, rho = rho)
#'Y0 <- c(X = log(100), Z = 2*sqrt(mu)) # initial value
#'dT <- 1/252 # financial convention for one observation per day
#'ndays <- 501
#'# simulation
#'hest.sim <- sde.sim(model = hest.model, init.data = Y0, params = theta,
#'                     dt = dT, dt.sim = dT/1e2, N = ndays, burn = 100)
#'
#'
#'# parameter inference with Lebesgue prior
#'# basic Euler approximation with no missing data
#'init <- sde.init(data = hest.sim$data, dt = hest.sim$dt, m = 0, par.index = 2,
#'                 params = hest.sim$params)
#'nsamples <- 5e3
#'rw.jump.sd <- c(.2, 2, .2, .1, .1) # standard deviations for random walk proposals
#'hest.post <- sde.post(model = hest.model, init = init, prior = NULL,
#'                      nsamples = nsamples, data.out.ind = data.out.ind, rw.jump.sd = rw.jump.sd)
#'
#'# plot the posterior densities
#'theta.names <- expression(alpha, gamma, beta, sigma, rho)
#'par(mfrow = c(2,3), mar = c(4, 4.5, .5, .5))
#'for(ii in 1:5) {
#'  hist(hest.post$params[,ii], breaks = 100, freq = FALSE,
#'       xlab = theta.names[ii], main = "")
#'  abline(v = theta[ii], col = "red")
#'}
#'legend(x = "topright", legend = expression(hat(p)[0](theta*" | "*Y), theta), fill = c("black", "red"))
#'
NULL

#'@name cop.par
#'@title Parameter Estimation of a Gaussian Copula Distribution
#'@description <description>
#'@param x a matrix
#'@param dens.x a matrix or a numeric or a list
#'@param dens.y a matrix or a numeric or a list
#'@param Rho
#'@param mean
#'@param sd standard deviation
#'@param from
#'@param to
#'@param n
#'@param ...
#'@param zero.dens boolean (\code{FALSE} by default)
#'@param sd.infl a real (1/5 by default)
#'@param debug a boolean (\code{FALSE} by default) if set to \code{TRUE}, will cause the function to open a browser mid-call
#'@return a list containing the estimated gaussian-copula distribution parameters: dens.x, dx, rx, dens.y, ldensy, Dens.y, Rho, mean, sd
#'@export
#'@examples
#'
#'# arbitrary correlation matrix
#'f <- function(n) {
#'  cov2cor(crossprod(matrix(rnorm(n^2), nrow = n, ncol = n)))
#'}
#'
#'theta <- c(alpha = .1, gamma = 5, beta = .8, sigma = .6, rho = -.7)
#'Y0 <- c(X = log(100), Z = .1)
#'
#'# define the prior on parameters and the first missing data point.
#'norm.prior <- c(theta, Y0[2]) # this will be the mean, and half of it will be the standard deviations
#'norm.prior <- list(Mu = norm.prior,
#'                   V = diag(abs(norm.prior)/2) %*% f(length(norm.prior)) %*% diag(abs(norm.prior)/2))
#'
#'# gaussian copula prior will be essentially identical
#'psim <- rmvnorm(1e5, mean = norm.prior$Mu*1.1, sigma = norm.prior$V*2)
#'gcop.prior <- cop.par(X = psim, n = 512)
#'
NULL

#'@name dcop
#'@title Density of a Gaussian Copula Distribution
#'@description Calculates the density of a gaussian copula distribution
#'@param x An array
#'@param par paramaters generated by \code{cop.par}
#'@param dens.x used as a parameter to \code{cop.par} if par if missing
#'@param dens.y used as a parameter to \code{cop.par} if par if missing
#'@param Rho used as a parameter to \code{cop.par} if par if missing
#'@param mean used as a parameter to \code{cop.par} if par if missing
#'@param sd used as a parameter to \code{cop.par} if par if missing
#'@param log A boolean (\code{FALSE} by default). If \code{TRUE}, this function will return the log of the density.
#'@param decomp A boolean (\code{FALSE} by default). If \code{TRUE}, this function will return a list containing
#'              the marginally Normalized data z, its multivariate log-density ldens.z, and the log-jacobian ljac.z,
#'              such that the total log-density is ldens.z + ljac.z
#'              instead of returning the density as a single array
#'@param max.z An integer. Normals will be truncated to +/- \code{max.z} standard deviations (default 10)
#'@param debug a boolean (\code{FALSE} by default) if set to \code{TRUE}, will cause the function to open a browser mid-call
#'@return the density as a numeric array
#'@export
NULL

#'@name rcop
#'@title Simulation of a Gaussian Copula Distribution
#'@description NOTE: problematic treatment of duplicate values in Dens.y.
#'             Only seems to be a problem for highly skewed marginals, so far...
#'@param n An integer giving the number of rows to be generated
#'@param par paramaters generated by \code{cop.par}
#'@param dens.x used as a parameter to \code{cop.par} if par if missing
#'@param dens.y used as a parameter to \code{cop.par} if par if missing
#'@param Rho used as a parameter to \code{cop.par} if par if missing
#'@param mean used as a parameter to \code{cop.par} if par if missing
#'@param sd used as a parameter to \code{cop.par} if par if missing
#'@param debug a boolean (\code{FALSE} by default) if set to \code{TRUE}, will cause the function to open a browser mid-call
#'@return a matrix of size \code{n} x \code{length(dens.x)}
#'@export
NULL

#'@name effect.size
#'@title effective sample size calculation
#'@description calculates the effective sample size for either the output of an MCMC sampler, or the weights of an importance sampler.
#'@param chain the output of an MCMC sampler for a single coordinate.
#'@param weights the weights for an importance sampler.
#'@param prop logical.  \code{prop = FALSE} returns the effective number of samples, whereas \code{prop = TRUE} returns it as a fraction.
#'@return A scalar.
#'@export
#'@examples
#'# Gibbs sampler for the bivariate Normal
#'rho <- .9
#'nsamples <- 1e3
#'X <- matrix(NA, nsamples, 2)
#'colnames(X) <- c("X1", "X2")
#'x <- c(0,0)
#'for(ii in 1:nsamples) {
#'  x[1] <- rnorm(1, mean = rho*x[2], sd = sqrt(1-rho^2))
#'  x[2] <- rnorm(1, mean = rho*x[1], sd = sqrt(1-rho^2))
#'  X[ii,] <- x
#'}
#'
#'# effective number of samples
#'apply(X, 2, effect.size, prop = FALSE)
#'
#'# Importance sampler with independent Normals as the proposal distribution
#'Xprop <- rmvnorm(nsamples, sigma = diag(2))
#'# calculate weights
#'lprop <- dmvnorm(Xprop, sigma = diag(2), log = TRUE)
#'ltarg <- dmvnorm(Xprop, sigma = cbind(c(1,rho), c(rho,1)), log = TRUE)
#'wgt <- ltarg - lprop
#'wgt <- exp(wgt - max(wgt))
#'wgt <- wgt/sum(wgt)
#'# resampling of proposals to approximate the target
#'Xtarg <- Xprop[sample(x = 1:nsamples, size = nsamples, replace = TRUE,  prob = wgt),]
#'
#'# proportion of effective samples
#'effect.size(weights = wgt, prop = TRUE)
NULL

#'@name ghestList
#'@docType data
#'@title Ghest Model Parameters
#'@description List of paramaters that can be passed to sde.make.model to produce a ghest model
#'@format a list containing ndims, nparams, param.names, data.names, sdeDr, sdeDf, isValidData, isValidParams
#'@keywords datasets
#'@export
NULL

#'@name gl05List
#'@docType data
#'@title gl05 Model Parameters
#'@description List of paramaters that can be passed to sde.make.model to produce a ghest model
#'@format a list containing ndims, nparams, param.names, data.names, sdeDr, sdeDf, isValidData, isValidParams
#'@keywords datasets
#'@export
NULL

#'@name hestList
#'@docType data
#'@title Heston Model Parameters
#'@description List of paramaters that can be passed to sde.make.model to produce a ghest model
#'@format A list containing ndims, nparams, param.names, data.names, sdeDr, sdeDf, isValidData, isValidParams
#'@keywords datasets
#'@export
NULL

#'@name sde.diff
#'@title Diffusion Function
#'@description Applies the diffusion function for \code{model} to \code{x} using \code{theta}
#'@param model An object of the sde.model class generated using \code{sde.make.model}
#'@param x A matrix of data
#'@param theta A matrix of parameters
#'@return A matrix containing the result of the diffusion function
#'@export
#'@examples
#'
#'# Create the model
#'hest.model <- sde.make.model(list = hestList, model.name = "hest")
#'
#'theta <- c(alpha = .1, gamma = 5, beta = .8, sigma = .6, rho = -.7)
#'Y0 <- c(X = log(100), Z = .1)
#'
#'# simulate data
#'N <- 10
#'burn <- 10
#'dT <- 1/252
#'
#'hsim <- sde.sim(model = hest.model, init.data = Y0, params = theta, dt = dT, dt.sim = dT/100,
#'                N = N, burn = burn, nreps = 1)
#'
#'diff <- sde.diff(model = hest.model, x = hsim$data, theta = theta)
#'
NULL

#'@name sde.drift
#'@title Drift Function
#'@description Applies the drift function for \code{model} to \code{x} using \code{theta}
#'@param model An object of the sde.model class generated using \code{sde.make.model}
#'@param x A matrix of data
#'@param theta A matrix of parameters
#'@return A matrix containing the result of the drift function
#'@export
#'@examples
#'
#'# Create the model
#'hest.model <- sde.make.model(list = hestList, model.name = "hest")
#'
#'theta <- c(alpha = .1, gamma = 5, beta = .8, sigma = .6, rho = -.7)
#'Y0 <- c(X = log(100), Z = .1)
#'
#'# simulate data
#'N <- 10
#'burn <- 10
#'dT <- 1/252
#'
#'hsim <- sde.sim(model = hest.model, init.data = Y0, params = theta, dt = dT, dt.sim = dT/100,
#'                N = N, burn = burn, nreps = 1)
#'
#'drift <- sde.drift(model = hest.model, x = hsim$data, theta = theta)
#'
NULL

#'@name sde.init
#'@title Posterior Sampler Initialization
#'@description  initialize posterior sampler for a given resolution level k, \cr
#'              or m missing data points per interval, i.e. m = 2^k-1. \cr
#'              currently only supports constant interobservation times.
#'@param data An array of data
#'@param dt A vector of Delta-t. Must have \code{length(dt) == 1 || length(dt) == nrow(data)-1}
#'@param k An integer representing a resolution level (only used if \code{m} is missing)
#'@param m An integerrepresenting the number of missing data points per interval
#'@param par.index An integer
#'@param params A vector of parameters that, if provided, will be included in the output of this function.
#'@param debug a boolean (FALSE by default) if set to \code{TRUE}, will cause the function to open a browser mid-call
#'@return a list containing: data, dt, par.index, params (only if \code{params} was passed to sde.init)
#'@export
#'@examples
#'
#'# Create the model
#'hest.model <- sde.make.model(list = hestList, model.name = "hest")
#'
#'theta <- c(alpha = .1, gamma = 5, beta = .8, sigma = .6, rho = -.7)
#'Y0 <- c(X = log(100), Z = .1)
#'
#'# simulate data
#'N <- 10
#'burn <- 10
#'dT <- 1/252
#'
#'hsim <- sde.sim(model = hest.model, init.data = Y0, params = theta, dt = dT, dt.sim = dT/100,
#'                N = N, burn = burn, nreps = 1)
#'
#'k <- 1
#'par.index <- 1
#'
#'init <- sde.init(data = hsim$data, dt = dT, k = k, par.index = par.index, params = theta)
#'
NULL

#'@name sde.loglik
#'@title Loglikelihood Function
#'@description Applies the log-likelihood function for \code{model} to \code{x} using \code{theta} and \code{dt}
#'@param model An object of the sde.model class generated using \code{sde.make.model}
#'@param x A matrix of size (nreps x ncomp x ndims) containing data
#'@param dt A numeric vector of size 1 or ncomp-1 containing Delta-t
#'@param theta A matrix of size (nreps x nparams) containing parameters
#'@param debug A boolean (\code{FALSE} by default) if set to \code{TRUE}, will cause the function to open a browser mid-call
#'@return a matrix containing the result of the log-likelihood function
#'@export
#'@examples
#'
#'# Create the model
#'hest.model <- sde.make.model(list = hestList, model.name = "hest")
#'
#'theta <- c(alpha = .1, gamma = 5, beta = .8, sigma = .6, rho = -.7)
#'Y0 <- c(X = log(100), Z = .1)
#'
#'# simulate data
#'N <- 10
#'burn <- 10
#'dT <- 1/252
#'
#'hsim <- sde.sim(model = hest.model, init.data = Y0, params = theta, dt = dT, dt.sim = dT/100,
#'                N = N, burn = burn, nreps = 1)
#'
#'loglik <- sde.loglik(model = hest.model, x = hsim$data, dt = dT, theta = theta)
#'
NULL

#'@name sde.make.model
#'@title Model Creation
#'@description Calling \code{sde.make.model} will compile the c++ code provided in its parameters along with
#'             c++ code included in this package in order to produce a shared library.
#'             The functions of this shared library should be accessed by passing the result of \code{sde.make.model}
#'             into any of the functions \code{sde.sim}, \code{sde.post}, \code{sde.diff}, \code{sde.drift},
#'             or \code{sde.loglik}
#'@param list \code{NULL} by default. Rather than passing model parameters to \code{sde.make.model} individually,
#'             the parameters may be passed as a list. Any combination of model parameters may be provided in this
#'             list (excluding debug and ...).
#'             Values from this list will only be used if no coresponding value is provided as a parameter to \code{sde.make.model}
#'@param ndims an integer giving the number of dimensions for the model
#'@param nparams an integer giving the number of parameters for the model
#'@param definitionFilePath The full file path of a file containing c++ definitions for \code{sdeDr}, \code{sdeDf},
#'                          \code{isValidData} and \code{isValidParams}\cr
#'                          If \code{definitionFilePath} is provided, any values for \code{sdeDr}, \code{sdeDf},
#'                          \code{isValidData} or \code{isValidParams} will be ignored.
#'                          The file must contain definitions for all 4 functions.
#'@param sdeDr A string of c++ code giving a function definition for the model's drift function. \cr
#'             The function's signature must be: void sdeDr(double dr[], double x[], double t, double params[])
#'@param sdeDf A string of c++ code giving a function definition for the model's diffusion function. \cr
#'             The function's signature must be: void sdeDf(double df[], double x[], double sqrtT, double params[])
#'@param isValidData A string of c++ code giving a function definition for the model's data validation function.\cr
#'             The function's signature must be: int isValidData(double x[]) \cr
#'             The return value must be 1 for valid data, 0 for invalid data
#'@param isValidParams A string of c++ code giving a function definition for the model's parameter validation function. \cr
#'             The function's signature must be: int isValidParams(double params[]) \cr
#'             The return value must be 1 for valid parameters, 0 for invalid parameters
#'@param logPrior A string of c++ code defining a custom prior for the model.\cr
#'             This parameter is optional.\cr
#'             If it is not provided, the values of CustomPriorClass, CustomPriorConstructor and .CustomPriorFunction
#'             will be used. \cr
#'             If it is provided, it must consist of a complete class definition meeting the criteria specified
#'             in the package vignette. \cr
#'             Custom priors are only relevant for those users who do not wish to use any of the provided priors
#'             (flat, normal and Gaussian Copula)
#'@param data.names a vector of names for the columns of data that will be used by the model
#'@param param.names a vector of names for the parameters that will be used by the model
#'@param ... additional parameters that are passed to sourceCpp when compiling the c++ code
#'@param debug a boolean (\code{FALSE} by default) if set to \code{TRUE}, will cause the function to open a browser mid-call
#'@return an sde.model containing:\cr \cr
#'                          ndims, \cr
#'                          nparams, \cr
#'                          logPrior, \cr
#'                          data.names, \cr
#'                          param.names, \cr
#'                          sim (simulation function for the model), \cr
#'                          post (posterior inference function for the model), \cr
#'                          drift (drift function for the model), \cr
#'                          diff (diffusion function for the model), \cr
#'                          loglik (loglikelihood function for the model) \cr \cr
#'
#'                          The functions \code{sim}, \code{post}, \code{drift}, \code{diff} and \code{loglik}
#'                          should never be called directly. Instead use \code{sde.sim}, \code{sde.post},
#'                          \code{sde.diff}, \code{sde.drift} and \code{sde.loglik}
#'@export
#'@examples
#'hest.model <- sde.make.model(list = hestList, cpp.out = TRUE)
#'names(hest.model)
#'# preview the C++ code
#'message(paste(hest.model$cpp.code[1:10], collapse = "\n"))
NULL

#'@name sde.post
#'@title Posterior Inference
#'@description Markov Chain Monte Carlo sampling of posterior distribution
#'@param model an object of the sde.model class generated using \code{sde.make.model}
#'@param init A list containing values for any combination of \code{init.data}, \code{init.params}, \code{par.index} and \code{dt}.
#'            Values provided in this list will be used instead of values provided as parameters to \code{sde.post}
#'@param init.data Data for the model
#'@param init.params Parameters for the model
#'@param par.index
#'@param dt Delta-t for the model
#'@param nsamples An integer giving the number of samples to generate with the Markov chain after the required
#'                number of samples have been burned
#'@param burn An integer giving the number of samples to burn before beginning to store samples
#'@param data.out.ind
#'@param prior A list containing the parameters for the model's prior function. \cr
#'             The parameters must have the correct names for the prior indicated by \code{prior.type} \cr
#'             normal: Mu, V \cr
#'             gcop: dens.x, dx, rx, dens.y, ldens.y, Dens.y, Rho, mean, sd \cr
#'             flat: flat prior does not accept parameters. Parameter list is ignored \cr
#'             custom: no argument checking for custom priors
#'@param prior.type A string denoting which prior should be used for Posterior Inference (\code{"default"} by default).\cr
#'                  Must be one of: default, flat, normal, gcop or custom\cr
#'                  if \code{"flat"} a flat prior will be used\cr
#'                  if \code{"normal"} a normal prior will be used\cr
#'                  if \code{"gcop"} a Gaussian Copula prior will be used\cr
#'                  if \code{"default"} the names of the parameters provided in \code{prior} will be used to determine
#'                      whether a normal or gcop prior should be used.
#'                      If the parameter list does not match either of these, a flat prior will be used\cr
#'                  if \code{"custom"} the custom prior that was passed to \code{sde.make.model} when \code{model} was created
#'                      will be used
#'@param rw.jump.sd A numeric vector containing random walk sd's (default \code{NULL})
#'@param update.data A boolean (default \code{TRUE})
#'@param update.params A boolean (default \code{TRUE})
#'@param update.multi A boolean (default \code{TRUE})
#'@param smp.old the result of a previous call to \code{sde.post}. Used for multi update
#'@param max.multi.tries An integer (default \code{5e3})
#'@param log.multi.acc A boolean. If \code{TRUE} and \code{update.multi == TRUE} log.multi.acc will be included in the output of this function (default \code{FALSE})
#'@param loglik.out A boolean. If \code{TRUE} loglik will be included in the output of this function (default \code{FALSE})
#'@param last.miss.out A boolean. If \code{TRUE} last.miss will be included in the output of this function (default \code{FALSE})
#'@param verbose A boolean that determines the amount of text printed out by \code{sde.post}. (default \code{TRUE})
#'@param debug a boolean (\code{FALSE} by default) if set to \code{TRUE}, will cause the function to open a browser mid-call
#'@return a list containing:\cr \cr
#'                          params, \cr
#'                          data, \cr
#'                          loglik (only if \code{loglik.out == TRUE}), \cr
#'                          dt, \cr
#'                          par.index, \cr
#'                          data.out.ind, \cr
#'                          init.data, \cr
#'                          init.params, \cr
#'                          rw.jump.sd, \cr
#'                          prior, \cr
#'                          prior.type, \cr
#'                          last.iter, \cr
#'                          last.miss (only if \code{last.miss.out == TRUE})\cr
#'                          multi.ind (only if \code{update.multi == TRUE})\cr
#'                          log.multi.acc (only if \code{update.multi == TRUE && log.multi.acc == TRUE})\cr
#'                          accept\cr
#'                          time
#'@export
#'@examples
#'# Create the model
#'hest.model <- sde.make.model(list = hestList, model.name = "hest")
#'
#'theta <- c(alpha = .1, gamma = 5, beta = .8, sigma = .6, rho = -.7)
#'Y0 <- c(X = log(100), Z = .1)
#'
#'# simulate data
#'N <- 10
#'burn <- 10
#'dT <- 1/252
#'
#'hsim <- sde.sim(model = hest.model, init.data = Y0, params = theta, dt = dT, dt.sim = dT/100,
#'                N = N, burn = burn, nreps = 1)
#'
#'# posterior inference
#'
#'# parameters of normal prior
#'norm.prior <- c(theta, Y0[2])
#'norm.prior <- list(Mu = norm.prior,
#'                   V = diag(abs(norm.prior)/2) %*% f(length(norm.prior)) %*% diag(abs(norm.prior)/2))
#'
#'k <- 1
#'par.index <- 1
#'init <- sde.init(data = hsim$data, dt = dT, k = k, par.index = par.index, params = theta)
#'
#'# reduce the prior on N random variables to n <= N
#'n <- length(theta) + hest.model$ndim - init$par.index[1]
#'norm.prior$Mu <- norm.prior$Mu[1:n]
#'norm.prior$V <- norm.prior$V[1:n,1:n]
#'
#'nsamples <- 10
#'burn <- 2
#'rw.jump.sd <- rep(.1, 6)
#'
#'hpost <- sde.post(model = hest.model, init = init, nsamples = nsamples, burn = burn,
#'                  data.out.ind = nsamples, rw.jump.sd = rw.jump.sd,
#'                  prior = norm.prior)
#'
#'
#'# and a different model
#'gl05.model <- sde.make.model(list = gl05List, model.name = "gl05")
#'
#'theta <- log(c(.1,.7, .35, .2, .1, .9, .3, .1))
#'names(theta) <- paste("c", 1:8, sep = "")
#'
#'Y0 <- c(R = 5, P = 5, Q = 5, D = 5)
#'
#'# simulation
#'N <- 10
#'burn <- 10
#'dT <- 1
#'
#'gsim <- sde.sim(model = gl05.model, init.data = Y0, params = theta, dt = dT, dt.sim = dT/1e5,
#'                N = N, burn = burn, nreps = 1)
#'
#'
#'# inference
#'
#'# prior
#'norm.prior <- c(theta, Y0[-1])
#'norm.prior <- list(Mu = norm.prior,
#'                   V = diag(abs(norm.prior)/2) %*% f(length(norm.prior)) %*% diag(abs(norm.prior)/2))
#'psim <- rmvnorm(1e5, mean = norm.prior$Mu*1.1, sigma = norm.prior$V*2)
#'gcop.prior <- cop.par(X = psim, n = 512)
#'
#'k <- 2 # or 1, 2, 3, ...
#'par.index <- sample(1:gl05.model$ndims, N, replace = TRUE) # 1,2,3, or 4, but not 0
#'init <- sde.init(data = gsim$data, dt = dT, k = k, par.index = par.index, params = theta)
#'
#'n <- length(theta) + gl05.model$ndim - init$par.index[1]
#'gcop.prior$dens.x <- gcop.prior$dens.x[1:n]
#'gcop.prior$dens.y <- gcop.prior$dens.y[1:n]
#'gcop.prior$Dens.y <- gcop.prior$Dens.y[1:n]
#'gcop.prior$dx <- gcop.prior$dx[1:n]
#'gcop.prior$ldens.y <- gcop.prior$ldens.y[1:n]
#'gcop.prior$mean <- gcop.prior$mean[1:n]
#'gcop.prior$Rho <- gcop.prior$Rho[1:n,1:n]
#'gcop.prior$rx <- gcop.prior$rx[1:(2*n)]
#'gcop.prior$sd <- gcop.prior$sd[1:n]
#'
#'nsamples <- 10
#'burn <- 2
#'rw.jump.sd <- rep(.1, gl05.model$ndims+gl05.model$nparams-1)
#'
#'gpost <- sde.post(model = gl05.model, init = init, nsamples = nsamples, burn = burn,
#'                  data.out.ind = nsamples, rw.jump.sd = rw.jump.sd,
#'                  prior = gcop.prior)
NULL

#'@name sde.sim
#'@title Simulation
#'@description Runs a simulation using the supplied model, data and parameters.
#'@param model an object of the sde.model class generated using \code{sde.make.model}
#'@param init.data A matrix containing data for the model.
#'                 Must have as many columns as the model has dimensions.
#'                 If \code{init.data} has only 1 row, that row will be repeated for each of the \code{nreps} Markov chains, otherwise
#'                 Must have as many rows as \code{nreps}
#'@param params A matrix containing parameters for the model
#'              Must have as many columns as the model has parameters
#'              If \code{params} has only 1 row, that row will be repeated for each of the \code{nreps} Markov chains, otherwise
#'              Must have as many rows as \code{nreps}
#'@param dt A double. The ratio of \code{dt/dt.sim} determines
#'                    how many intermediate steps there will be between each stored value
#'@param dt.sim A double The ratio of \code{dt/dt.sim} determines
#'                       how many intermediate steps there will be between each stored value
#'@param N An integer that determines how many data values will be stored for each Markov chain
#'@param burn An integer representing the number of data values to burn for each Markov chain (default \code{0})
#'            OR a double 0 < burn < 1 representing the number of data values to burn for each chain as a fraction of N
#'@param nreps An integer giving the number of Markov chains to use
#'@param max.bad.draws An integer giving the maximum number of times that invalid data can be encountered in the simulation (default \code{5e3})
#'@param verbose A boolean that determines how much text is printed out by this function (default \code{TRUE})
#'@param debug a boolean (\code{FALSE} by default) if set to \code{TRUE}, will cause the function to open a browser mid-call
#'@return a list containing: data, params, dt, dt.sim, nbad
#'@export
#'@examples
#'# Create the model
#'hest.model <- sde.make.model(list = hestList)
#'
#'theta <- c(alpha = .1, gamma = 5, beta = .8, sigma = .6, rho = -.7) # parameters
#'Y0 <- c(X = log(100), Z = .1) # initial values
#'
#'# simulate data
#'N <- 100
#'burn <- 0
#'dT <- 1/252
#'
#'hsim <- sde.sim(model = hest.model, init.data = Y0, params = theta, dt = dT, dt.sim = dT/100,
#'                N = N, burn = burn, nreps = 1)
#'
#'
#'# plot
#'par(mfrow = c(1,2))
#'plot(hsim$data[,"X"], type = "l", xlab = "Time (days)", ylab = expression(X[t]))
#'plot(hsim$data[,"Z"]^2/4, type = "l", xlab = "Time (days)", ylab = expression(V[t]))
#'
NULL

#'@name dhest
#'@title Stationary Distribution of Heston Model Log-Return Differences
#'@description these will roughly be centered at alpha*dT \cr
#'             requires Fourier inversion of the characteristic function, ie. numerical \cr
#'             complex integration.  currently done by grid method. \cr
#'             LConst allows fewer exp evaluations if alpha is held constant. \cr
#'@param x
#'@param alpha
#'@param gamma
#'@param mu
#'@param beta
#'@param sigma
#'@param rho
#'@param dT
#'@param inter
#'@param n
#'@param LConst
#'@param debug a boolean (\code{FALSE} by default) if set to \code{TRUE}, will cause the function to open a browser mid-call
#'@return numeric
#'@export
NULL

#'@name sv.init
#'@title Initialize Missing Volatility
#'@description <description>
#'@param x
#'@param dt
#'@param vblock.size
#'@param debug a boolean (\code{FALSE} by default) if set to \code{TRUE}, will cause the function to open a browser mid-call
#'@return a list containing: alpha, v
#'@export
NULL

#'@name dgcir
#'@title gcir stationary distribution (regular scale)
#'@description <description>
#'@param x
#'@param gamma
#'@param mu
#'@param sigma
#'@param lambda
#'@param log
#'@param debug a boolean (\code{FALSE} by default) if set to \code{TRUE}, will cause the function to open a browser mid-call
#'@return a numeric vector
#'@export
NULL

